\chapter{Neprázdnost bezkontextových gramatik}
\label{sec:Grammars}

\section{Teoretický základ}
\label{sec:GrammarsTheory}

Problém neprázdnosti jazyka bezkontextové gramatiky (CFG Non-emptiness Problem) je dalším příkladem P-úplného problému \cite{sawa}. Bezkontextová gramatika představuje formální systém sloužící k generování jazyka, který hraje klíčovou roli v definování syntaxe programovacích jazyků i v analýze neprogramovacích jazyků.

Formálně je gramatika definována jako čtveřice \( G = (N, \Sigma, P, S) \) \cite{uti_grammars}, kde:

\begin{itemize}
    \item \( N \) je konečná množina neterminálních symbolů (neterminálů).
    \item \( \Sigma \) je konečná množina terminálních symbolů (terminálů), disjunktní s \( N \).
    \item \( P \) je konečná množina přepisovacích pravidel tvaru \( A \to \alpha \), kde \( A \in N \) a \( \alpha \in (N \cup \Sigma)^* \).
    \item \( S \in N \) je počáteční symbol (start symbol).
\end{itemize}

Problém spočívá v tom, zda daná gramatika generuje alespoň jedno slovo složené pouze z terminálních symbolů:

\begin{itemize}
    \item \textbf{Vstup:} Bezkontextová gramatika \( G = (N, \Sigma, P, S) \).
    \item \textbf{Výstup:} Rozhodnutí, jestli je jazyk \( L(G) = \{ w \in \Sigma^* \mid S \Rightarrow^* w \} \) neprázdný.
\end{itemize}

Symbol \( \Rightarrow^* \) označuje derivaci v nula nebo více krocích \cite{uti_grammars}. Gramatika generuje neprázdný jazyk právě tehdy, když z počátečního symbolu \( S \) lze odvodit alespoň jedno slovo složené pouze z terminálních symbolů.

\subsection{P-úplnost problému}
\label{sec:GrammarsCompleteness}

Problém neprázdnosti jazyka bezkontextové gramatiky je P-úplný \cite{sawa, miyano}. Tento problém lze vyřešit v polynomiálním čase pomocí algoritmu iterativního označování produktivních neterminálů. Produktivní neterminál je takový, ze kterého lze derivovat řetězec složený pouze z terminálů \cite{sawa}.

I přes řešitelnost v polynomiálním čase je problém P-úplný, což naznačuje obtížnou paralelizovatelnost. Produktivita jednoho neterminálu často závisí na produktivitě jiných neterminálů. Tato vzájemná závislost vyžaduje sekvenční zpracování podobné vyhodnocování MCVP obvodu.

\section{Formát vstupu}
\label{sec:GrammarsInput}

Aplikace nabízí tři způsoby zadávání bezkontextové gramatiky:

\begin{itemize}
    \item \textbf{Manuální zadání:} Uživatel definuje gramatiku pomocí textového pole, kde se zadá celá gramatika najednou (viz sekce \ref{sec:GrammarsManual}).
    \item \textbf{Generování náhodných gramatik:} Automatické vytvoření náhodné gramatiky podle zadaných parametrů (viz sekce \ref{sec:GrammarsGeneration}).
    \item \textbf{Předpřipravené sady:} Načtení ukázkových příkladů gramatik (viz sekce \ref{sec:GrammarsPreparedSets}).
\end{itemize}

Všechny formy vstupu využívají stejnou komponentu pro zobrazení derivačního stromu gramatiky implementovanou ve třídě \texttt{Grammar} (modul \texttt{Grammar.js}).

\section{Manuální zadání gramatiky}
\label{sec:GrammarsManual}

Komponenta \texttt{ManualInput} poskytuje rozhraní ve formě textového okna pro přímé zadávání pravidel gramatiky.

\begin{itemize}
    \item \textbf{Syntaktický formát:} Každé pravidlo se zapisuje na nový řádek ve tvaru \texttt{LS -> PS}. Pro oddělení více alternativ na pravé straně se používá symbol \texttt{|}. Symboly v rámci jedné alternativy musí být odděleny mezerami.
    
    \item \textbf{Kategorizace symbolů:} Algoritmus v modulu \texttt{GrammarParser.js} automaticky rozpoznává typy symbolů. Symboly složené čistě z velkých písmen (včetně českých znaků s diakritikou) jsou považovány za neterminály. Jakékoliv jiné řetězce jsou identifikovány jako terminály.
    
    \item \textbf{Epsilon pravidla:} Pro vyjádření prázdného řetězce ($\epsilon$) lze použít přímo slovo \texttt{epsilon} nebo řecké písmeno.
    
    \item \textbf{Počáteční symbol:} První neterminál uvedený na levé straně prvního pravidla je automaticky nastaven jako počáteční symbol \( S \).
\end{itemize}

Příklad vstupu:
\begin{verbatim}
S -> a S b | epsilon
\end{verbatim}

Aplikace během zpracování textu provádí validaci a kontroluje správnost formátu pravidel. Validace upozorňuje na tyto typy chyb:

\begin{itemize}
    \item \textbf{Chybějící levá nebo pravá strana:} Pravidlo musí obsahovat jak levou stranu (neterminál), tak pravou stranu. Parser zobrazí chybu, pokud v pravidle chybí šipka \texttt{->} nebo pokud je některá strana prázdná.
    
    \item \textbf{Neplatný neterminál:} Levá strana pravidla musí být složena pouze z velkých písmen (včetně českých znaků s diakritikou).
    
    \item \textbf{Zapomenutá mezera:} Parser detekuje pravděpodobné chyby, jako je zapomenutá mezera mezi neterminálem a terminálem (např. \texttt{aS}), což by bylo chybně identifikováno jako jeden terminální symbol. V takovém případě parser navrhne správné oddělení symbolů mezerami.
\end{itemize}

\section{Generování náhodných gramatik}
\label{sec:GrammarsGeneration}

Modul \texttt{GrammarGenerator.js} obsahuje funkci \texttt{generateGrammar()} pro vytváření náhodných bezkontextových gramatik na základě vstupních parametrů. Komponenta \texttt{GenerateInput} poskytuje uživatelské rozhraní s možností nastavení základních i pokročilých parametrů.

\subsection{Základní parametry}
\label{sec:GrammarsGenerationBasic}

Základní parametry umožňují rychlé vygenerování gramatiky a určují její velikost a strukturu. Prvním parametrem je počet neterminálů v rozmezí 1 až 10. Druhým parametrem je počet terminálů, taktéž v rozmezí 1 až 10. Třetí parametr určuje maximální délku pravé strany, zde se mohou zadat hodnoty v rozmezí 1 až 5, přičemž délka každého pravidla je náhodně zvolena v intervalu od 1 do hodnoty tohoto parametru.

\subsection{Pokročilé parametry}
\label{sec:GrammarsGenerationAdvanced}

Pokročilé parametry umožňují větší kontrolu nad vlastnostmi generované gramatiky:

\begin{itemize}
    \item \textbf{Počet pravých stran na neterminál:} 
    \begin{itemize}
        \item Min (1-10): Minimální počet pravidel pro každý neterminál
        \item Max: Maximální počet pravidel, automaticky omezen na rozmezí od hodnoty parametru Min do 10
        \item Pro každý neterminál se náhodně zvolí počet pravidel v tomto rozmezí
    \end{itemize}
    
    \item \textbf{Rekurze:} Kontrola nad rekurzivními pravidly:
    \begin{itemize}
        \item Levá rekurze: Povoluje pravidla tvaru \( A \to A \alpha \)
        \item Pravá rekurze: Povoluje pravidla tvaru \( A \to \alpha A \)
        \item Pokud jsou obě vypnuté, generátor vytváří pouze pravidla bez rekurze
        \item Pravděpodobnost aplikace rekurze je 30\% při povoleném režimu
    \end{itemize}
    
    \item \textbf{Generování epsilon (\( \epsilon \)):} Tři režimy:
    \begin{itemize}
        \item \textbf{Ne:} Negenerují se žádná epsilon pravidla
        \item \textbf{Náhodně:} Epsilon pravidla se generují s pravděpodobností 8\%
        \item \textbf{Vždy:} Epsilon pravidla se generují s pravděpodobností 15\%, přičemž je garantován alespoň jeden výskyt v gramatice
    \end{itemize}
\end{itemize}

\subsection{Algoritmus generování}
\label{sec:GrammarsGenerationAlgorithm}

Algoritmus generování probíhá v těchto krocích:

\begin{enumerate}
    \item \textbf{Vytvoření symbolů:} Generují se pole neterminálů a terminálů podle zadaných počtů. První neterminál je automaticky nastaven jako počáteční symbol \( S \) gramatiky.
    
    \item \textbf{Generování pravidel pro každý neterminál:} 
    \begin{enumerate}
        \item Náhodně se určí počet pravidel pro tento neterminál (v rozmezí vstupních parametrů - min-max)
        \item Pro každé pravidlo:
        \begin{itemize}
            \item Kontrola epsilon režimu – jestli je povolená generace epsilon terminálu, je zde šance na jeho vytvoření (podle zvoleného režimu)
            \item Jinak určení náhodné délky pravé strany (1 až vstupní parametr max délka pravé strany)
            \item Náhodný výběr symbolů – terminály s pravděpodobností 50\%, neterminály s 50\%
            \item Aplikace rekurze – přidání neterminálu na začátek/konec dle nastavení
        \end{itemize}
    \end{enumerate}
    
    \item \textbf{Sestavení gramatiky:} Vytvoření instance třídy \texttt{Grammar} s vygenerovanými symboly a pravidly.
\end{enumerate}

\section{Předpřipravené sady}
\label{sec:GrammarsPreparedSets}

Ve složce \texttt{Sady/Grammar} jsou uloženy předpřipravené příklady gramatik. Tyto sady slouží ke kontrolované demonstraci specifických příkladů.

\subsection{Ukládání a načítání gramatik}
\label{sec:GrammarsSerialization}

Gramatiky lze exportovat a importovat ve formátu JSON pomocí komponenty \texttt{FileTransferControls}. Formát obsahuje:

\begin{itemize}
    \item Pole \texttt{terminals} se seznamem terminálních symbolů
    \item Pole \texttt{nonTerminals} se seznamem neterminálních symbolů
    \item Pole \texttt{productions} s pravidly, kde každé pravidlo má \texttt{ls} (levou stranu) a \texttt{ps} (pravou stranu jako pole symbolů)
    \item \texttt{startSymbol} určující počáteční neterminál
\end{itemize}

Tento formát umožňuje sdílení gramatik mezi uživateli a vytváření předpřipravených příkladů.



\section{Algoritmus vyhodnocení}
\label{sec:GrammarsAlgorithm}

Modul \texttt{GrammarEvaluator.js} obsahuje implementaci algoritmu pro vyhodnocení neprázdnosti gramatiky. Algoritmus zjišťuje, zda je počáteční symbol \( S \) produktivní – tedy zda z něj lze odvodit slovo složené pouze z terminálů nebo prázdný řetězec \( \epsilon \).

\subsection{Identifikace produktivních neterminálů}
\label{sec:GrammarsProductive}

Algoritmus pracuje iterativně a postupně označuje produktivní neterminály \cite{sawa}:

\begin{enumerate}
    \item \textbf{Inicializace:} Vytvoříme prázdnou množinu produktivních symbolů \( \mathcal{P} \).
    
    \item \textbf{Základní krok:} Do \( \mathcal{P} \) přidáme všechny neterminály \( A \), které mají pravidlo \( A \to w \), kde \( w \in \Sigma^* \) (pravá strana obsahuje pouze terminály nebo je prázdná).
    
    \item \textbf{Iterativní rozšiřování:} Opakovaně procházíme všechna pravidla. Pokud existuje pravidlo \( A \to X_1 X_2 \dots X_k \), kde všechny symboly \( X_i \) jsou buď terminály nebo již jsou v množině \( \mathcal{P} \), přidáme \( A \) do \( \mathcal{P} \).
    
    \item \textbf{Ukončení:} Opakujeme krok 3, dokud se množina \( \mathcal{P} \) mění.
    
    \item \textbf{Výsledek:} Pokud \( S \in \mathcal{P} \), pak jazyk \( L(G) \) není prázdný. V opačném případě je \( L(G) = \emptyset \).
\end{enumerate}

Implementace používá optimalizovanou verzi s frontou (work-list algorithm), což odpovídá principu algoritmu průchodu do šířky (BFS). Místo procházení všech pravidel v každém cyklu udržujeme frontu nově označených produktivních neterminálů a kontrolujeme pouze ta pravidla, která tyto neterminály obsahují na pravé straně.

Časová složitost algoritmu je \( O(|P| \cdot l) \) \cite{uti_grammars}, kde \( |P| \) značí celkový počet pravidel a \( l \) je maximální délka pravé strany pravidla. Každé pravidlo je totiž kontrolováno nejvýše jednou pro každý symbol na pravé straně.

\subsection{Rekonstrukce derivace}
\label{sec:GrammarsWitness}

%clean

Algoritmus během svého běhu zaznamenává pro každý produktivní neterminál všechna jeho produktivní pravidla. Na rozdíl od základní verze algoritmu, která ukládá pouze první nalezené produktivní pravidlo, implementace uchovává všechna produktivní pravidla pro každý neterminál. Tato data jsou ukládána do mapy \texttt{allWitnesses}, která pro každý produktivní neterminál obsahuje pole všech jeho produktivních pravých stran.

Po dokončení analýzy produktivních neterminálů je možné provést sestavení derivačního stromu, pokud je počáteční symbol \( S \) produktivní. Sestavení probíhá rekurzivně:

\begin{enumerate}
    \item \textbf{Výběr pravidla:} Pro každý neterminál náhodně vybereme jedno z jeho produktivních pravidel. Při větší hloubce derivace (> 20 kroků) preferujeme nerekurzivní pravidla, aby se předešlo nekonečným derivacím.
    
    \item \textbf{Limitace hloubky:} Rekurzivní konstrukce stromu je omezena na maximální hloubku 30 úrovní. Pokud je tato hloubka překročena, vrátí se chyba a místo vykreslení stromu se zobrazí informační zpráva.
    
    \item \textbf{Stavba uzlů:} Strom se buduje rekurzivně funkcí \texttt{buildNode()}:
    \begin{itemize}
        \item Pro každý neterminál vytvoříme uzel s unikátním identifikátorem
        \item Náhodně vybereme jedno z jeho produktivních pravidel
        \item Pro každý symbol na pravé straně pravidla rekurzivně vytvoříme potomky (zvýšíme hloubku o 1)
        \item Terminály a \( \epsilon \) vytvoří listy stromu bez dalších potomků
    \end{itemize}
    
    \item \textbf{Extrakce slova:} Funkce \texttt{extractTerminals()} prochází strom zleva doprava a čte terminální listy, čímž získá řetězec vygenerovaný danou derivací.
\end{enumerate}

Tato rekonstrukce slouží nejen jako důkaz neprázdnosti jazyka, ale také jako vizuální pomůcka pro pochopení struktury generovaných slov. Náhodný výběr pravidel znamená, že při každém vyhodnocení může být vygenerováno jiné slovo.

\section{Vizualizace derivačního stromu}
\label{sec:GrammarsVisualization}

Pokud gramatika generuje neprázdný jazyk, aplikace nejen potvrdí tento fakt, ale také vizuálně ukáže důkaz vykreslením derivačního stromu pro jedno z možných slov.

\subsection{Komponenta pro vykreslení}
\label{sec:GrammarsTreeComponent}

Pro vykreslení derivačního stromu je využit algoritmus z komponenty \texttt{DerivationTreeVisual}, která využívá knihovnu \emph{react-force-graph-2d}. Strom je zobrazen ve stromovém rozložení pomocí režimu \texttt{dagMode="td"} (top-down).

\section{Krokové vyhodnocení}
\label{sec:GrammarsStepByStep}

Pro detailnější pochopení algoritmu implementuje aplikace krokovatelnou analýzu prostřednictvím komponenty \texttt{StepByStepGrammar}. Tato komponenta využívá modul \texttt{GrammarStepEvaluator.js} k simulaci algoritmu a zobrazuje průběh výpočtu v modálním okně.

\subsection{Struktura zobrazení}
\label{sec:GrammarsStepByStepStructure}

Rozhraní krokového vyhodnocení je rozčleněno do několika sekcí:

\begin{itemize}
    \item \textbf{Seznam pravidel gramatiky:} Zobrazuje všechna produktivní pravidla. Aktuálně kontrolované pravidlo je vizuálně zvýrazněno žlutým pozadím a oranžovým ohraničením. Pravidla, jejichž levá strana je již produktivní, jsou označena zeleným štítkem s textem „Produktivní".
    
    \item \textbf{Množina produktivních symbolů:} Aktuální obsah množiny \( \mathcal{P} \) je zobrazen formou zelených štítků s písmenem neterminálu. Tato množina se postupně rozšiřuje během jednotlivých iterací algoritmu, za podmínky že gramatika obsahuje produktivní neterminály.
    
    \item \textbf{Vysvětlení kroku:} Textový popis aktuální operace algoritmu, například „Pravidlo \( A \to a \) obsahuje pouze terminály. \( A \) je produktivní" nebo „Pravidlo se stalo produktivním díky \( B \). \( A \) přidán mezi produktivní".
\end{itemize}

\subsection{Navigace a ovládání}
\label{sec:GrammarsStepByStepNavigation}

Pro pohyb mezi jednotlivými kroky analýzy jsou k dispozici čtyři navigační tlačítka:

\begin{itemize}
    \item \textbf{Začátek:} Přesun na první krok algoritmu (inicializace prázdné množiny \( \mathcal{P} \))
    \item \textbf{Předchozí:} Krok zpět v historii výpočtu
    \item \textbf{Další:} Posun na následující krok
    \item \textbf{Konec:} Skok na finální krok s výsledkem analýzy
\end{itemize}

Aktuální pozice je indikována čítačem ve formátu „Krok \( x \) z \( n \)", kde \( n \) představuje celkový počet kroků. Tato interaktivní vizualizace umožňuje sledovat, jak algoritmus postupně identifikuje produktivní neterminály na základě již známých produktivních symbolů a jak závislosti mezi pravidly určují pořadí jejich vyhodnocení.