\chapter{Prázdnost bezkontextových gramatik}
\label{sec:Grammars}

\section{Teoretický základ}
\label{sec:GrammarsTheory}

Problém prázdnosti bezkontextových gramatik (CFG Emptiness Problem) je dalším příkladem P-úplného problému \cite{sawa}. Bezkontextová gramatika představuje formální systém sloužící k generování jazyka, který hraje klíčovou roli v defininovaní syntaxe programovacích jazyků i v analýze neprogramovacích jazyků.

Formálně je gramatika definována jako čtveřice \( G = (N, \Sigma, P, S) \), kde:

\begin{itemize}
    \item \( N \) je konečná množina neterminálních symbolů (neterminálů).
    \item \( \Sigma \) je konečná množina terminálních symbolů (terminálů), disjunktní s \( N \).
    \item \( P \) je konečná množina přepisovacích pravidel tvaru \( A \to \alpha \), kde \( A \in N \) a \( \alpha \in (N \cup \Sigma)^* \).
    \item \( S \in N \) je počáteční symbol (start symbol).
\end{itemize}

Problém spočívá v tom, zda daná gramatika generuje alespoň jedno slovo složené pouze z terminálních symbolů:

\begin{itemize}
    \item \textbf{Vstup:} Bezkontextová gramatika \( G = (N, \Sigma, P, S) \).
    \item \textbf{Výstup:} Rozhodnutí, jestli je jazyk \( L(G) = \{ w \in \Sigma^* \mid S \Rightarrow^* w \} \) neprázdný.
\end{itemize}

Symbol \( \Rightarrow^* \) označuje derivaci v nula nebo více krocích \cite{sawa}. Gramatika generuje neprázdný jazyk právě tehdy, když z počátečního symbolu \( S \) lze odvodit alespoň jedno slovo složené pouze z terminálních symbolů.

\subsection{P-úplnost problému}
\label{sec:GrammarsCompleteness}

Problém prázdnosti bezkontextových gramatik je P-úplný \cite{sawa}. Tento problém lze vyřešit v polynomiálním čase pomocí algoritmu iterativního označování produktivních neterminálů. Produktivní neterminál je takový, ze kterého lze derivovat řetězec složený pouze z terminálů \cite{sawa}.

I přes řešitelnost v polynomiálním čase je problém P-úplný, což naznačuje obtížnou paralelizovatelnost. Produktivita jednoho neterminálu často závisí na produktivitě jiných neterminálů. Tato vzájemná závislost vyžaduje sekvenční zpracování podobné vyhodnocování MCVP obvodu.

\section{Formát vstupu}
\label{sec:GrammarsInput}

Aplikace nabízí tři způsoby zadávání bezkontextové gramatiky:

\begin{itemize}
    \item \textbf{Manuální zadání:} Uživatel definuje gramatiku pomocí textového pole, kde se zadá celá gramatika najednou (viz sekce \ref{sec:GrammarsManual}).
    \item \textbf{Generování náhodných gramatik:} Automatické vytvoření náhodné gramatiky podle zadaných parametrů (viz sekce \ref{sec:GrammarsGeneration}).
    \item \textbf{Předpřipravené sady:} Načtení ukázkových příkladů gramatik (viz sekce \ref{sec:GrammarsPreparedSets}).
\end{itemize}

Všechny formy vstupu využívají stejnou komponentu pro zobrazení derivačního stromu gramatiky implementovanou ve třídě \texttt{Grammar} (modul \texttt{Grammar.js}).

\section{Manuální zadání gramatiky}
\label{sec:GrammarsManual}

Komponenta \texttt{ManualInput} poskytuje rozhraní ve formě textového okna pro přímé zadávání pravidel gramatiky.

\begin{itemize}
    \item \textbf{Syntaktický formát:} Každé pravidlo se zapisuje na nový řádek ve tvaru \texttt{LS -> PS}. Pro oddělení více alternativ na pravé straně se používá symbol \texttt{|}. Symboly v rámci jedné alternativy musí být odděleny mezerami.
    
    \item \textbf{Kategorizace symbolů:} Algoritmus v modulu \texttt{GrammarParser.js} automaticky rozpoznává typy symbolů. Symboly složené čistě z velkých písmen (včetně českých znaků s diakritikou) jsou považovány za neterminály. Jakékoliv jiné řetězce jsou identifikovány jako terminály.
    
    \item \textbf{Epsilon pravidla:} Pro vyjádření prázdného řetězce ($\epsilon$) lze použít přímo slovo \texttt{epsilon} nebo řecké písmeno.
    
    \item \textbf{Počáteční symbol:} První neterminál uvedený na levé straně prvního pravidla je automaticky nastaven jako počáteční symbol \( S \).
\end{itemize}

Příklad vstupu:
\begin{verbatim}
S -> a S b | epsilon
\end{verbatim}

Aplikace během zpracování textu provádí validaci a kontroluje správnost formátu pravidel. Validace upozorňuje na tyto typy chyb:

\begin{itemize}
    \item \textbf{Chybějící levá nebo pravá strana:} Pravidlo musí obsahovat jak levou stranu (neterminál), tak pravou stranu. Parser zobrazí chybu, pokud v pravidle chybí šipka \texttt{->} nebo pokud je některá strana prázdná.
    
    \item \textbf{Neplatný neterminál:} Levá strana pravidla musí být složena pouze z velkých písmen (včetně českých znaků s diakritikou).
    
    \item \textbf{Zapomenutá mezera:} Parser detekuje pravděpodobné chyby, jako je zapomenutá mezera mezi neterminálem a terminálem (např. \texttt{aS}), což by bylo chybně identifikováno jako jeden terminální symbol. V takovém případě parser navrhne správné oddělení symbolů mezerami.
\end{itemize}

\section{Generování náhodných gramatik}
\label{sec:GrammarsGeneration}

Modul \texttt{GrammarGenerator.js} obsahuje funkci \texttt{generateGrammar()} pro vytváření náhodných bezkontextových gramatik na základě vstupních parametrů. Komponenta \texttt{GenerateInput} poskytuje uživatelské rozhraní s možností nastavení základních i pokročilých parametrů.

\subsection{Základní parametry}
\label{sec:GrammarsGenerationBasic}

Základní parametry umožňují rychlé vygenerování gramatiky a určují její velikost a strukturu. Prvním parametrem je počet neterminálů v rozmezí 1 až 10. Druhým parametrem je počet terminálů, taktéž v rozmezí 1 až 10. Třetí parametr určuje maximální délku pravé strany, zde se mohou zadat hodnoty v rozmezí 1 až 5, přičemž délka každého pravidla je náhodně zvolena mezi hodnotou 1 a hodnotou tohoto parametru.

\subsection{Pokročilé parametry}
\label{sec:GrammarsGenerationAdvanced}

Pokročilé parametry umožňují větší kontrolu nad vlastnostmi generované gramatiky:

\begin{itemize}
    \item \textbf{Počet pravých stran na neterminál:} 
    \begin{itemize}
        \item Min (1-10): Minimální počet pravidel pro každý neterminál
        \item Max: Maximální počet pravidel, automaticky omezen na rozmezí od hodnoty parametru Min do 10
        \item Pro každý neterminál se náhodně zvolí počet pravidel v tomto rozmezí
    \end{itemize}
    
    \item \textbf{Rekurze:} Kontrola nad rekurzivními pravidly:
    \begin{itemize}
        \item Levá rekurze: Povoluje pravidla tvaru \( A \to A \alpha \)
        \item Pravá rekurze: Povoluje pravidla tvaru \( A \to \alpha A \)
        \item Pokud jsou obě vypnuté, generátor vytváří pouze pravidla bez rekurze
        \item Pravděpodobnost aplikace rekurze je 30\% při povoleném režimu
    \end{itemize}
    
    \item \textbf{Generování epsilon (\( \epsilon \)):} Tři režimy:
    \begin{itemize}
        \item \textbf{Ne:} Negenerují se žádná epsilon pravidla
        \item \textbf{Náhodně:} Epsilon pravidla se generují s pravděpodobností 8\%
        \item \textbf{Vždy:} Epsilon pravidla se generují s pravděpodobností 15\%, přičemž je garantován alespoň jeden výskyt v gramatice
    \end{itemize}
\end{itemize}

\subsection{Algoritmus generování}
\label{sec:GrammarsGenerationAlgorithm}

Algoritmus generování probíhá v těchto krocích:

\begin{enumerate}
    \item \textbf{Vytvoření symbolů:} Generují se pole neterminálů a terminálů podle zadaných počtů. První neterminál je automaticky nastaven jako počáteční symbol \( S \) gramatiky.
    
    \item \textbf{Generování pravidel pro každý neterminál:} 
    \begin{enumerate}
        \item Náhodně se určí počet pravidel pro tento neterminál (v rozmezí vstupních parametrů - min-max)
        \item Pro každé pravidlo:
        \begin{itemize}
            \item Kontrola epsilon režimu – jestli je povolená generace epsilon terminálu, je zde šance na jeho vytvoření (podle zvoleného režimu)
            \item Jinak určení náhodné délky pravé strany (1 až vstupní parametr max délka pravé strany)
            \item Náhodný výběr symbolů – terminály s pravděpodobností 50\%, neterminály s 50\%
            \item Aplikace rekurze – přidání neterminálu na začátek/konec dle nastavení
        \end{itemize}
    \end{enumerate}
    
    \item \textbf{Sestavení gramatiky:} Vytvoření instance třídy \texttt{Grammar} s vygenerovanými symboly a pravidly.
\end{enumerate}

\section{Předpřipravené sady}
\label{sec:GrammarsPreparedSets}

Ve složce \texttt{Sady/Grammar} jsou uloženy předpřipravené příklady gramatik. Tyto sady slouží ke kontolované demonstraci specifických příkladů.

\subsection{Ukládání a načítání gramatik}
\label{sec:GrammarsSerialization}

Gramatiky lze exportovat a importovat ve formátu JSON pomocí komponenty \texttt{FileTransferControls}. Formát obsahuje:

\begin{itemize}
    \item Pole \texttt{terminals} se seznamem terminálních symbolů
    \item Pole \texttt{nonTerminals} se seznamem neterminálních symbolů
    \item Pole \texttt{productions} s pravidly, kde každé pravidlo má \texttt{ls} (levou stranu) a \texttt{ps} (pravou stranu jako pole symbolů)
    \item \texttt{startSymbol} určující počáteční neterminál
\end{itemize}

Tento formát umožňuje sdílení gramatik mezi uživateli a vytváření předpřipravených příkladů.

%clean

\section{Algoritmus vyhodnocení}
\label{sec:GrammarsAlgorithm}

Řešení problému prázdnosti gramatiky je implementováno v modulu \texttt{GrammarEvaluator.js}. Algoritmus zjišťuje, zda je počáteční symbol \( S \) produktivní – tedy zda z něj lze odvodit slovo složené pouze z terminálů nebo prázdný řetězec \( \epsilon \).

\subsection{Identifikace produktivních neterminálů}
\label{sec:GrammarsProductive}

Algoritmus pracuje iterativně a postupně označuje produktivní neterminály \cite{sawa}:

\begin{enumerate}
    \item \textbf{Inicializace:} Vytvoříme prázdnou množinu produktivních symbolů \( \mathcal{P} \).
    
    \item \textbf{Základní krok:} Do \( \mathcal{P} \) přidáme všechny neterminály \( A \), které mají pravidlo \( A \to w \), kde \( w \in \Sigma^* \) (pravá strana obsahuje pouze terminály nebo je prázdná).
    
    \item \textbf{Iterativní rozšiřování:} Opakovaně procházíme všechna pravidla. Pokud existuje pravidlo \( A \to X_1 X_2 \dots X_k \), kde všechny symboly \( X_i \) jsou buď terminály nebo již jsou v množině \( \mathcal{P} \), přidáme \( A \) do \( \mathcal{P} \).
    
    \item \textbf{Ukončení:} Opakujeme krok 3, dokud se množina \( \mathcal{P} \) mění.
    
    \item \textbf{Výsledek:} Pokud \( S \in \mathcal{P} \), pak jazyk \( L(G) \) není prázdný. V opačném případě je \( L(G) = \emptyset \).
\end{enumerate}

Implementace používá optimalizovanou verzi s frontou (work-list algorithm). Místo procházení všech pravidel v každém cyklu udržujeme frontu nově označených produktivních neterminálů a kontrolujeme pouze ta pravidla, která tyto neterminály obsahují na pravé straně.

Časová složitost algoritmu je \( O(|P| \cdot l) \), kde \( |P| \) je počet pravidel a \( l \) je maximální délka pravé strany pravidla, protože každé pravidlo je kontrolováno nejvýše jednou pro každý symbol na pravé straně.

\subsection{Rekonstrukce svědka}
\label{sec:GrammarsWitness}

Během běhu algoritmu si pro každý produktivní neterminál ukládáme tzv. svědky (witnesses) – všechna produktivní pravidla pro daný neterminál, nikoliv pouze první. Tato informace je uložena v mapě \texttt{allWitnesses}, která pro každý neterminál obsahuje pole všech jeho produktivních pravých stran.

Po skončení analýzy, pokud je počáteční symbol \( S \) produktivní, můžeme rekurzivně rekonstruovat derivační strom:

\begin{enumerate}
    \item \textbf{Výběr pravidla:} Pro každý neterminál náhodně vybereme jedno z jeho produktivních pravidel. Při větší hloubce derivace (> 20 kroků) preferujeme nerekurzivní pravidla, aby se předešlo nekonečným derivacím.
    
    \item \textbf{Limitace hloubky:} Rekurzivní konstrukce stromu je omezena na maximální hloubku 50 úrovní. Pokud je tato hloubka překročena, vyhodí se chyba a strom se nevykreslí.
    
    \item \textbf{Stavba uzlů:} Pro každý neterminál:
    \begin{itemize}
        \item Vytvoříme uzel se symbolem a unikátním ID
        \item Vybereme náhodné produktivní pravidlo
        \item Rekurzivně vytvoříme potomky pro každý symbol na pravé straně
        \item Terminály a \( \epsilon \) tvoří listy stromu
    \end{itemize}
    
    \item \textbf{Extrakce slova:} Z vytvořeného stromu extraujeme vygenerované slovo zleva doprava čtením terminálních listů.
\end{enumerate}

Tato rekonstrukce slouží nejen jako důkaz neprázdnosti jazyka, ale také jako vizuální pomůcka pro pochopení struktury generovaných slov. Náhodný výběr pravidel znamená, že při každém vyhodnocení může být vygenerováno jiné slovo.

\section{Vizualizace derivačního stromu}
\label{sec:GrammarsVisualization}

Pokud gramatika generuje neprázdný jazyk, aplikace nejen potvrdí tento fakt, ale také vizuálně demonstruje důkaz vykreslením derivačního stromu pro jedno z možných slov.

\subsection{Komponenta pro vykreslení}
\label{sec:GrammarsTreeComponent}

Pro vykreslení derivačního stromu je využita komponenta \texttt{DerivationTreeVisual}, která je postavená na knihovně \emph{react-force-graph-2d}. Strom je zobrazen v hierarchickém rozložení pomocí režimu \texttt{dagMode="td"} (top-down).

\subsubsection{Vizuální prvky}
\label{sec:GrammarsVisualElements}

\begin{itemize}
    \item \textbf{Neterminály:} Zobrazeny standardní barvou definovanou v konfiguraci (\texttt{useGraphColors}), reprezentují mezikroky v derivaci.
    
    \item \textbf{Terminály:} Zvýrazněny kontrastní barvou (standardně žlutá), aby bylo na první pohled zřejmé, které symboly tvoří výsledné slovo. Listy stromu čtené zleva doprava tvoří vygenerované slovo.
    
    \item \textbf{Epsilon (\( \epsilon \)):} Zobrazeny specifickou barvou (standardně šedá) pro reprezentaci prázdného řetězce. Tyto uzly signalizují místa, kde byla aplikována epsilon pravidla.
    
    \item \textbf{Hrany:} Reprezentují aplikaci přepisovacích pravidel – hrana z uzlu \( A \) do uzlu \( B \) znamená, že symbol \( B \) se objevuje na pravé straně pravidla použitého pro derivaci z \( A \).
\end{itemize}

\subsubsection{Interaktivita a responsivita}
\label{sec:GrammarsInteractivity}

Komponenta využívá několik moderních přístupů pro zajištění dobrého uživatelského zážitku:

\begin{itemize}
    \item \textbf{Responsivní rozměry:} Komponenta využívá \texttt{ResizeObserver} API pro automatické přizpůsobení velikosti grafu při změně velikosti okna nebo kontejneru.
    
    \item \textbf{Jednotné nastavení:} Barvy a další vizuální parametry jsou spravovány pomocí custom React hooks:
    \begin{itemize}
        \item \texttt{useGraphColors}: Poskytuje konzistentní barevné schéma napříč aplikací
        \item \texttt{useGraphSettings}: Poskytuje specifická nastavení pro derivační stromy gramatik
    \end{itemize}
    
    \item \textbf{Interaktivní ovládání:} Uživatel může:
    \begin{itemize}
        \item Přibližovat a oddalovat pomocí kolečka myši
        \item Posouvat pohled tažením
        \item Přesouvat jednotlivé uzly pro lepší přehlednost
    \end{itemize}
\end{itemize}

\section{Krokové vyhodnocení}
\label{sec:GrammarsStepByStep}

Pro detailnější pochopení algoritmu implementuje aplikace krokovatelnou analýzu. Komponenta sleduje jednotlivé iterace algoritmu a zobrazuje:

\begin{itemize}
    \item Aktuální stav množiny produktivních neterminálů \( \mathcal{P} \)
    \item Právě kontrolované pravidlo
    \item Rozhodnutí, zda pravidlo přidává nový produktivní neterminál
    \item Textové vysvětlení každého kroku
\end{itemize}

Uživatel může procházet kroky analýzy pomocí navigačních tlačítek – k dispozici jsou tlačítka „Předchozí", „Další", „Začátek" a „Konec" pro rychlý přesun. Tato funkce pomáhá pochopit, jak algoritmus postupně buduje množinu produktivních neterminálů a jak závislosti mezi pravidly ovlivňují výsledek.