\chapter{Monotone Circuit Value Problem}
\label{sec:MCVP}

\section{Teoretický základ}
\label{sec:MCVPTheory}

Monotone Circuit Value Problem je základní problém v teorii složitosti, který patří mezi P-úplné problémy \cite{sawa}. Jeho definice je následující:

\begin{itemize}
    \item \textbf{Vstup:} Booleovský obvod bez negací, tvořený pouze hradly AND ($\land$) a OR ($\lor$), společně se vstupními proměnnými (pouze hodnoty 0 nebo 1 - false nebo true).
    \item \textbf{Výstup:} Hodnota výstupního uzlu obvodu (kořene stromu).
\end{itemize}

Obvod lze reprezentovat jako orientovaný acyklický graf (DAG), kde uzly představují buď vstupní proměnné (listy) nebo logická hradla (vnitřní uzly). Hrany reprezentují tok logických hodnot – přenášejí výsledky vyhodnocení z jednoho uzlu jako vstupy do uzlů následujících. V monotónním obvodu chybí hradla NOT, což zajišťuje, že funkce reprezentovaná obvodem je monotónní – zvýšení hodnoty libovolného vstupu nikdy nesníží hodnotu výstupu \cite{papadimitriou1993}.

\subsection{P-úplnost MCVP}
\label{sec:MCVPCompleteness}

MCVP je P-úplný problém \cite{arora2009}. Vyhodnocení monotónního obvodu lze provést v polynomiálním čase postupným vyhodnocováním uzlů od vstupů směrem k výstupu. Přestože je problém v třídě P, jeho P-úplnost naznačuje, že pravděpodobně neexistuje efektivní paralelní algoritmus pro jeho řešení – problém vyžaduje sekvenční zpracování.

\section{Formát vstupu a parsování výrazů}
\label{sec:MCVPParsing}

Aplikace umožňuje zadat monotónní obvod několika způsoby. Jako první je textový zápis ve formě logického výrazu, který je následně převeden na stromovou strukturu.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{IMGs/InputSelectorMCVP.png}
    \caption{Výběr způsobu zadání vstupu pro MCVP}
    \label{fig:input-selector-mcvp}
\end{figure}

\subsection{Gramatika vstupního jazyka}
\label{sec:MCVPGrammar}

Vstupní výrazy odpovídají jednoduché gramatice:

\begin{itemize}
    \item Operátory \texttt{O} (OR) a \texttt{A} (AND) reprezentují logický součet a součin.
    \item Proměnné jsou zapsány ve tvaru \texttt{x1[0]} nebo \texttt{x2[1]}, kde číslo v hranatých závorkách udává hodnotu proměnné (0 nebo 1).
    \item Výrazy lze libovolně uzávorkovat pomocí kulatých závorek pro určení priority vyhodnocení.
\end{itemize}

Příklad platného výrazu: \texttt{((x1[1] A x2[0]) O (x3[1] A x4[1]))}

\subsection{Lexikální a syntaktická analýza}
\label{sec:MCVPLexer}

Převod textového výrazu na stromovou strukturu probíhá ve dvou fázích, které jsou implementovány v modulu \texttt{Parser.js}:

\begin{enumerate}
    \item \textbf{Tokenizace (lexikální analýza):} Funkce \texttt{tokenize()} rozdělí vstupní řetězec na posloupnost tokenů. Každý token je dvojice (typ, hodnota), například \texttt{['LPAREN', '(']} nebo \texttt{['VARIABLE', 'x1[1]']}. Tokenizér rozpoznává závorky, operátory (A, O) a proměnné pomocí regulárních výrazů.
    
    \item \textbf{Parsování (syntaktická analýza):} Třída \texttt{Parser} implementuje rekurzivní sestupný parser. Parser je strukturován podle priority operátorů: \texttt{parseOrExpr()} zpracovává OR výrazy, \texttt{parseAndExpr()} zpracovává AND výrazy a \texttt{parseFactor()} zpracovává závorky a proměnné. Parser vytváří uzly typu \texttt{Node}, které tvoří stromovou strukturu reprezentující zadaný obvod.
\end{enumerate}

Výsledkem parsování je stromová struktura, kde listy jsou proměnné s přiřazenými hodnotami a vnitřní uzly reprezentují logické operace.

\section{Vyhodnocení obvodu}
\label{sec:MCVPEvaluation}

Vyhodnocení monotónního obvodu probíhá rekurzivním průchodem stromové struktury, který je implementován v modulu \texttt{EvaluateTree.js}.

\subsection{Algoritmus vyhodnocení}
\label{sec:MCVPAlgorithm}

Funkce \texttt{evaluateTree()} používá algoritmus průchodu do hloubky (DFS) s memoizací:

\begin{enumerate}
    \item \textbf{Listy (proměnné):} Pro uzly typu \texttt{variable} funkce vrací přímo přiřazenou hodnotu (0 nebo 1).
    
    \item \textbf{Vnitřní uzly (operace):} Pro uzly reprezentující logické operace funkce nejdříve vyhodnotí všechny potomky. Pokud je uzel typu AND, výsledek je 1 právě tehdy, když všichni potomci mají hodnotu 1. Pokud je uzel typu OR, výsledek je 1 pouze tehdy, když alespoň jeden potomek má hodnotu 1.
    
    \item \textbf{Memoizace:} Vyhodnocené hodnoty uzlů jsou uloženy do cache (slovníku), aby nedocházelo k opakovanému výpočtu stejných podstromů.
    
    \item \textbf{Detekce cyklů:} Algoritmus používá množinu \texttt{visiting} pro detekci případných cyklů v grafu, které by způsobily nekonečnou rekurzi.
\end{enumerate}

Časová složitost algoritmu je $O(n)$, kde $n$ je počet uzlů v obvodu, protože každý uzel je vyhodnocen právě jednou díky memoizaci.

\subsection{Krokové vyhodnocení}
\label{sec:MCVPStepByStep}

Aplikace také nabízí krokovatelné vyhodnocení pomocí funkce \texttt{evaluateTreeWithSteps()}. Tato funkce provádí stejný výpočet jako \texttt{evaluateTree()}, ale navíc zaznamenává při každém výpočtu i stav zbytku stromové struktury. Uživatel tak může sledovat, jak se hodnoty šíří od listů ke kořeni stromové struktury a lépe pochopit princip vyhodnocování.

Komponenta \texttt{StepByStepTree} zobrazuje každý krok graficky – aktuálně vyhodnocovaný uzel je zvýrazněn a vedle grafu je zobrazena informace o hodnotách vstupů a výsledku operace.

\section{Interaktivní editace obvodu}
\label{sec:MCVPInteractive}

Kromě textového zadání umožňuje aplikace vytvářet a upravovat obvody pomocí grafického editoru implementovaného v komponentě \texttt{InteractiveMCVPGraph}. Uživatel může:

\begin{itemize}
    \item \textbf{Přidávat uzly:} Pomocí tlačítek pod grafem lze vložit nové uzly typu AND, OR nebo vstupní proměnnou s hodnotou 0 nebo 1. Nový uzel se umístí do grafu, ale není propojen s ostatními uzly.
    
    \item \textbf{Vytvářet hrany:} Označit uzel, ten následně může:
    \begin{itemize}
        \item Nastavit na AND nebo OR operaci.
        \item Nastavit na proměnnou s hodnotou 0 nebo 1.
        \item Odstranit uzel z grafu.
        \item Vytvořit nebo odstranit hranu s dalším uzlem.
    \end{itemize}
        
    \item \textbf{Reorganizovat graf:} Uzly lze přesouvat myší pro lepší vizuální uspořádání obvodu.
\end{itemize}


\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{IMGs/ControlsForInteractiveMCVP.png}
    \caption{Ovládací prvky pro interaktivní editor obvodů MCVP}
    \label{fig:controls-interactive-mcvp}
\end{figure}

Grafický editor využívá knihovnu \emph{react-force-graph} pro vykreslování a interakci (viz kapitola \ref{sec:GraphVisualization}). Aplikace průběžně aktualizuje interní stromovou strukturu odpovídající aktuálnímu stavu grafu.

\section{Generování náhodných obvodů}
\label{sec:MCVPGeneration}

Aplikace obsahuje generátor náhodných obvodů v modulu \texttt{Generator.js}. Uživatel může upravit dva parametry:

\begin{itemize}
    \item \textbf{Počet hradel:} Kolik uzlů s operacemi (hradel AND a OR) bude obvod obsahovat.
    \item \textbf{Počet proměnných:} Kolik uzlů s proměnnými (listů) bude obvod obsahovat.
\end{itemize}

Generování probíhá v těchto fázích: Nejprve algoritmus vytvoří zadaný počet proměnných, s náhodnou hodnotou 0 nebo 1. Pak postupně přidává hradla. Pro každé hradlo vypočítáme cílový počet potomků podle vzorce $\lceil n / k \rceil$, kde $n$ je počet dosud dostupných uzlů a $k$ počet zbývajících hradel. K této hodnotě přidáme náhodnou odchylku $\pm 20\%$ – tak dosáhneme vyváženosti mezi úplnou náhodností a vyrovnanou distribucí. Hradlo pak náhodně vybere určený počet uzlů jako potomky a náhodně zvolí operaci (AND nebo OR) a přidá se do množiny použitelných uzlů pro potomky. Poslední hradlo spojí všechny zbývající uzly a stane se kořenem. Výsledný graf je platný DAG.

\section{Vizualizace obvodu}
\label{sec:MCVPVisualization}

Vizualizace monotónního obvodu je implementována v komponentě \texttt{TreeRenderCanvas}. Obvod je zobrazen jako stromový graf s kořenem nahoře a listy dole, takže hodnoty se šíří zdola nahoru.

\subsection{Hierarchické rozložení}
\label{sec:MCVPLayout}

Pro vizualizaci stromu používá aplikace knihovnu \emph{react-force-graph-2d}. Uzly jsou automaticky umístěny do vrstev podle jejich vzdálenosti od kořene díky režimu \texttt{dagMode="td"} (top-down neboli shora dolů). Rozložení kombinuje hierarchickou strukturu s fyzikálními silami pro optimální vizuální uspořádání grafu.

\section{Převod na kombinatorickou hru}
\label{sec:MCVPtoGame}

Pro ilustraci vzájemné převoditelnosti P-úplných problémů implementujeme převod z MCVP na kombinatorickou hru (popsaný v kapitole \ref{sec:Games}). Tento převod se nachází v modulech \texttt{ConversionCombinatorialGame.js} a \texttt{MCVPtoCombinatorialGameConverter.jsx}.

\subsection{Princip převodu}
\label{sec:MCVPtoGameRules}

V tomto převodu se mapují uzly obvodu MCVP na pozice ve hře dvou hráčů \cite{sawa}. Každý typ uzlu odpovídá specifické herní situaci:

\begin{itemize}
    \item \textbf{Hradlo OR} vytváří pozici pro Hráče 1 (hráč I je na tahu). Ten si může vybrat libovolnou následující pozici odpovídající potomkům hradla. Stačí, aby jedna z možností vedla k jeho výhře.
    
    \item \textbf{Hradlo AND} vytváří pozici pro Hráče 2 (hráč II je na tahu). Ten vybírá následující pozici a~snaží se zabránit výhře Hráče 1. Hráč 1 vyhraje pouze pokud vyhrává ve všech možných pokračováních.
    
    \item \textbf{Proměnná s hodnotou 1} odpovídá konečné pozici, ve které Hráč 2 nemá žádné tahy – Hráč 1 tedy vyhrává.
    
    \item \textbf{Proměnná s hodnotou 0} odpovídá konečné pozici, ve které Hráč 1 nemá žádné tahy a~prohrává.
\end{itemize}

Převod zachovává výsledek řešení: Hráč I v kombinatorické hře vyhrává tehdy, když se MCVP obvod vyhodnotí na 1.

\subsection{Implementace převodu}
\label{sec:MCVPtoGameImplementation}

Třída \texttt{MCVPToGameStepGenerator} prochází MCVP strom rekurzivně a pro každý uzel vytváří odpovídající pozici ve hře včetně hran k pozicím potomků. Pro efektivitu používáme memoizaci – každý uzel zpracujeme právě jednou, i kdyby se v obvodu vyskytoval vícekrát (například při sdílených podstromech).

Vizualizace probíhá pomocí komponenty \texttt{MCVPtoCombinatorialGameConverter}, která zobrazuje převod krokovatelně. Na levé straně vidí uživatel původní obvod se zvýrazněným aktuálně zpracovávaným uzlem, vpravo vznikající graf kombinatorické hry. Navigační tlačítka umožňují procházet kroky převodu k dalšímu i předešlému kroku.

\section{Převod na bezkontextovou gramatiku}
\label{sec:MCVPtoGrammar}

Druhá implementovaný převod transformuje MCVP obvod na bezkontextovou gramatiku (viz kapitola \ref{sec:Grammars}). Hodnota výsledku je zde taktéž zachována – gramatika generuje neprázdný jazyk právě tehdy, když obvod vyhodnotí na 1.

\subsection{Pravidla převodu}
\label{sec:MCVPtoGrammarPrinciple}

Převod mapuje uzly MCVP obvodu na symboly gramatiky \cite{sawa}:

\begin{itemize}
    \item \textbf{Kořen obvodu} se mapuje na počáteční symbol gramatiky $S$.
    
    \item \textbf{Hradlo AND s potomky $A$ a $B$} vytvoří pravidlo $X \to AB$, kde $X$ reprezentuje hradlo. Řetězec lze z $X$ odvodit právě tehdy, když lze odvodit řetězce z obou potomků $A$ i $B$.
    
    \item \textbf{Hradlo OR s potomky $A$ a $B$} vytvoří dvě pravidla: $X \to A$ a $X \to B$ ($X \to A \mid B$). Stačí, když lze řetězec odvodit alespoň z jednoho potomka.
    
    \item \textbf{Proměnná s hodnotou 1} generuje epsilon pravidlo $X \to \varepsilon$, což umožňuje odvození prázdného řetězce a gramatika tak může generovat neprázdný jazyk.
    
    \item \textbf{Proměnná s hodnotou 0} vytvoří pravidlo $X \to t$, kde $t$ je terminál bez dalších odvozovacích pravidel. Z tohoto neterminálu tak nelze odvodit žádný řetězec složený pouze z terminálů.
\end{itemize}

Výsledná gramatika generuje neprázdný jazyk právě tehdy, když obvod vyhodnotí na 1.

\subsection{Implementace převodu}
\label{sec:MCVPtoGrammarImplementation}

Převod implementuje třída \texttt{MCVPToGrammarConverter} (modul \texttt{MCVPtoGrammarConverter.jsx}). Nejprve \texttt{NonTerminalGenerator} přiřadí každému uzlu obvodu unikátní symbol – kořen dostane počáteční symbol $S$, ostatní uzly postupně symboly $A$, $B$, $C$, atd. Poté funkce \texttt{createProductionsRecursively()} rekurzivně prochází strom a generuje gramatická pravidla podle typu jednotlivých uzlů.

Pro konstrukci gramatiky používáme pomocnou třídu \texttt{ConversionGrammar} (soubor \texttt{ConversionGrammar.js}), která rozšiřuje standardní třídu \texttt{Grammar} o metody pro přidávání symbolů a pravidel.

Stejně jako u prvního převodu, komponenta \texttt{MCVPtoGrammarConverter} nabízí krokovou vizualizaci celého procesu. Uživatel tak může sledovat, jak obvod postupně přechází na gramatiku, a vidět, která pravidla vznikají z~konkrétních uzlů.

\section{Ukládání a načítání MCVP obvodů}
\label{sec:MCVPSerialization}

Aby si mohl uživatel uložit specifický obvod, podporuje aplikace export a import obvodů ve formátu JSON. Modul \texttt{Serialization.js} obsahuje potřebné funkce. Funkce \texttt{treeToFlatGraph()} převede stromovou strukturu na JSON objekt s poli uzlů a hran, kde každý uzel má unikátní ID, typ, hodnotu a případně přiřazenou binární hodnotu (export). Opačný převod zajišťuje \texttt{flatGraphToTree()} funkce, která z JSON formátu načte stromovou strukturu včetně hran mezi uzly.

\subsection{Předpřipravené sady}
\label{sec:MCVPPreparedSets}

Aplikace nabízí několik předpřipravených sad MCVP obvodů ve složce \texttt{Sady/MCVP}. Tyto sady slouží jako základní ukázkové příklady. Tyto uložené obvody jsou taktéž ve formatu JSON.
