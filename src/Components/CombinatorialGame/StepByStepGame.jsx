import { useState, useEffect, useMemo } from 'react';
import PropTypes from 'prop-types';
import { DisplayGraph } from './Utils/DisplayGraph';
import { computeWinner } from './Utils/ComputeWinner';

/**
 * Component for visualizing the step-by-step winning strategy analysis for a combinatorial game.
 * Uses the iterative steps generated by computeWinner.
 * 
 * @component
 * @param {Object} props - The component props
 * @param {Object} props.graph - The game graph to analyze
 */
export function StepByStepGame({ graph }) {
  const [steps, setSteps] = useState([]);
  const [currentStep, setCurrentStep] = useState(0);
  
  // Load steps from computeWinner
  useEffect(() => {
    if (graph) {
      const result = computeWinner(graph);
      // Prepend an initial "Start" step
      const allSteps = [
        {
          type: 'INIT',
          explanation: 'Začátek analýzy. Všechny pozice jsou inicializovány na REMÍZA (nedefinováno). Hledáme koncové pozice.',
          accumulatedStatus: {}
        },
        ...result.steps
      ];
      setSteps(allSteps);
      setCurrentStep(0);
    }
  }, [graph]);

  // Navigation functions
  const goToNextStep = () => {
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    }
  };

  const goToPreviousStep = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };

  const goToFirstStep = () => {
    setCurrentStep(0);
  };

  const goToLastStep = () => {
    setCurrentStep(steps.length - 1);
  };

  // Construct the accumulated winning map for the current step
  // We can't rely on the step object having the full map unless we build it here.
  // The steps from computeWinner are incremental updates.
  // So we need to compute the state at `currentStep`.
  
  const currentStatusMap = useMemo(() => {
    const map = {};
    // Replay steps up to currentStep
    for (let i = 1; i <= currentStep; i++) { // Skip INIT step 0
      const step = steps[i];
      if (step && step.id) {
         // Determine winning player based on status relative to node owner
         // step.status is 'WIN' or 'LOSE' for the player at step.id
         const nodePlayer = graph.positions[step.id].player;
         let winner = 0;
         if (step.status === 'WIN') {
             winner = nodePlayer;
         } else if (step.status === 'LOSE') {
             winner = nodePlayer === 1 ? 2 : 1;
         }
         
         if (winner !== 0) {
             map[step.id] = winner;
         }
      }
    }
    return map;
  }, [currentStep, steps, graph]);

  // Determine optimal moves for visualization
  // Optimal moves are edges from P1-Winning node to P1-Winning node.
  // We use currentStatusMap where 1 = P1 Win, 2 = P2 Win (P1 Lose).
  const currentOptimalMoves = useMemo(() => {
      const moves = new Set();
      for (const posId in graph.positions) {
          // If this position is determined as P1 Winning (map value 1) AND it's P1's turn
          // (Wait, optimal moves logic in DisplayGraph usually just highlights P1 winning paths)
          // Let's stick to: From P1-Win to P1-Win.
          
          if (currentStatusMap[posId] === 1 && graph.positions[posId].player === 1) {
               const children = graph.positions[posId].children || [];
               children.forEach(childId => {
                   if (currentStatusMap[childId] === 1) {
                       moves.add(`${posId}-${childId}`);
                   }
               });
          }
      }
      return moves;
  }, [currentStatusMap, graph]);

  const activeStep = steps[currentStep];

  return (
    <div className="step-by-step-container px-4 d-flex flex-column" style={{ height: '100%', overflow: 'hidden' }}>
      <h2 className="text-center mb-3" style={{ flexShrink: 0 }}>Postupná analýza výherní strategie</h2> 
      {steps.length > 0 ? (
        <>
          <div className="flex-grow-1 d-flex flex-column" style={{ minHeight: 0, overflow: 'auto' }}>
            <DisplayGraph 
              graph={graph} 
              optimalMoves={currentOptimalMoves}
              highlightedNode={activeStep?.id}
              winningPlayerMap={currentStatusMap}
            />
          </div>
          
          <div className='step-controls-info container-fluid mt-3' style={{ flexShrink: 0 }}>
          <div className='row align-items-center'>
            <div className='step-info col-md-7'>
              <div className="card p-3 bg-light" style={{ minHeight: '140px' }}>
                <p className="mb-1"><strong>Krok:</strong> {activeStep?.type === 'INIT' ? 'Inicializace' : (activeStep?.type === 'TERMINAL' ? 'Nalezen koncový uzel' : 'Aktualizace stavu')}</p>
                
                {activeStep?.id && (
                    <p className="mb-1">
                        <strong>Pozice:</strong> {activeStep.id} (Hráč {graph.positions[activeStep.id].player})
                    </p>
                )}
                
                <p className="mb-1"><strong>Vysvětlení:</strong> {activeStep?.explanation}</p>
                
                {activeStep?.status && (
                    <p className="mb-0">
                    <strong>Stav:</strong>{' '}
                    <span className={
                        (activeStep.status === 'WIN' && graph.positions[activeStep.id].player === 1) || 
                        (activeStep.status === 'LOSE' && graph.positions[activeStep.id].player === 2) 
                        ? 'text-success fw-bold' : 'text-danger fw-bold'
                    }>
                        {activeStep.status === 'WIN' ? 'Výherní' : 'Prohrávající'} (pro hráče {graph.positions[activeStep.id].player})
                    </span>
                    </p>
                )}
              </div>
            </div>
            <div className='step-controls col-md-5 d-flex flex-column align-items-center justify-content-center'>
              <p className="text-center mb-2">Krok {currentStep} z {steps.length - 1}</p>
              <div className="d-flex gap-2">
                <button className='btn btn-secondary btn-sm' onClick={goToFirstStep} disabled={currentStep === 0}>
                  &#x23EE; Začátek
                </button>
                <button className='btn btn-secondary' onClick={goToPreviousStep} disabled={currentStep === 0}>
                  &larr; Předchozí
                </button>
                <button className='btn btn-primary' onClick={goToNextStep} disabled={currentStep === steps.length - 1}>
                  Další &rarr;
                </button>
                <button className='btn btn-primary btn-sm' onClick={goToLastStep} disabled={currentStep === steps.length - 1}>
                  Konec &#x23ED;
                </button>
              </div>
            </div>
          </div>
          </div>
        </>
      ) : (
        <div className="alert alert-info text-center">
            Probíhá výpočet nebo nejsou k dispozici žádné kroky...
        </div>
      )}
    </div>
  );  
}

StepByStepGame.propTypes = {
  graph: PropTypes.shape({
    positions: PropTypes.object.isRequired,
    startingPosition: PropTypes.object.isRequired
  }).isRequired
};